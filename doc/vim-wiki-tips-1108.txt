*vim-wiki-tips-1108.txt*   Replace selected shell command with full path when editing scripts *vwt-1108*



Please review this tip:
    - This tip was imported from vim.org and needs general review [https://vim.fandom.com/wiki/Vim_Tips_Wiki:General_guidelines].
    - You might clean up comments [https://vim.fandom.com/wiki/Vim_Tips_Wiki:Comment_guidelines] or merge similar tips [https://vim.fandom.com/wiki/Vim_Tips_Wiki:Merge_guidelines].
    - Add suitable categories [https://vim.fandom.com/wiki/Vim_Tips_Wiki:Category_guidelines] so people can find the tip.
    - Please avoid the discussion page [https://vim.fandom.com/wiki/Vim_Tips_Wiki:Discussion_guidelines] (use the Comments section below for notes).
    - If the tip contains good advice for current Vim, remove the {{review}} line.
Tip 1108 [https://vim.fandom.com/wiki/Replace_selected_shell_command_with_full_path_when_editing_scripts]   Previous |vwt-1107| Next |vwt-1109|

created 2006 · complexity basic · author l1th10n · version 5.7

==============================================================================

This page is dodgy [https://vim.fandom.com/wiki/Category:Dodgy]. The contents 
may not be useful for Vim 7. If you think this tip is useful, please edit it 
to make the problem and its solution more understandable, and remove the 
{{Dodgy}} tag.

What exactly does this have to do with Vim? Please give a detailed example of 
how to use this in Vim (including before and after text)

When writing bash scripts and sudoers files, it can be tedious to determine 
the paths of the commands. Here is a procedure to use the which command to 
return the path of the selected word:

>
    !which $(cat)
<

To convert a bash command to a fully-explicit bash command, the key sequence 
would be "w!which $(cat)". $(cat) simply uses the selected text from the pipe 
and uses this text as an argument to the 'which' command. This method is great 
for using commands that use arguments instead of stdin. However, as far as I 
know, it works only in bash.

This command could be mapped to a key sequence if required.

COMMENTS  *vwt-1108-comments*

For this to work with csh and tcsh you have to enclose the 'cat' command in 
backticks. So you have to use:

>
    which `cat`
<

Also make sure your 'shellpipe' is set to "|& tee". See :help 'shellpipe'.

The backtick version also works with bash.

==============================================================================

In fact, the $(cmd) notation is general for all bourne compatible shells. But 
as bourne and csh-like shells accept the `cmd` notation, it is more general 
(although I prefer $(cmd) when dealing with bourne shells for it is 
recursive).

==============================================================================

This will also do the trick on Unix:

>
    :echo globpath(substitute($PATH, ':', ',', 'g'), 'cat')
<

On Windows, you will have to translate ';' (instead of ':') into ',', and 
replace 'cat' by 'cat.exe'.

These solutions will work even without 'which' installed on the system. The 
path translation mechanism is wrapped in :SearchInPATH from script#229 
[https://www.vim.org/scripts/script.php?script_id=229].

==============================================================================

Simpler:

>
    !xargs which
<

==============================================================================

I'm missing the point of the $(cat) notation. What is this doing?

To just get the full path to a command, you can do

>
    :.!which cat
<

This will insert the text "/usr/bin/cat" at the cursor.

==============================================================================

I believe the $() notation passes the currently highlighted word (in visual 
mode) to the shell.

==============================================================================